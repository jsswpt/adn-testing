{"version":3,"file":"static/js/321.9e2df66d.chunk.js","mappings":"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","sources":["../node_modules/classnames/index.js","../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js","../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.js","../node_modules/use-sync-external-store/shim/index.js","../node_modules/use-sync-external-store/shim/with-selector.js","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/effector-react/effector-react/createWatch.ts","../node_modules/effector-react/effector-react/withDisplayName.ts","../node_modules/effector-react/effector-react/apiBase.ts","../node_modules/effector-react/effector-react/scope.ts","../node_modules/effector-react/effector-react/nossr.ts","../node_modules/effector-react/effector-react/throw.ts","../node_modules/effector-react/effector-react/useIsomorphicLayoutEffect.ts","../node_modules/effector/effector/collection.ts","../node_modules/effector/effector/throw.ts","../node_modules/effector/effector/createNode.ts","../node_modules/effector/effector/tag.ts","../node_modules/effector/effector/kernel.ts","../node_modules/effector/effector/naming.ts","../node_modules/effector/effector/config.ts","../node_modules/effector/effector/template.ts","../node_modules/effector/effector/createUnit.ts","../node_modules/effector/effector/combine.ts","../node_modules/effector/effector/defer.ts","../node_modules/effector/effector/createEffect.ts","../node_modules/effector/effector/merge.ts","../node_modules/effector/effector/sample.ts","../node_modules/effector/effector/guard.ts","../node_modules/effector/effector/observable.ts","../node_modules/effector/effector/getter.ts","../node_modules/effector/effector/validate.ts","../node_modules/effector/effector/id.ts","../node_modules/effector/effector/region.ts","../node_modules/effector/effector/own.ts","../node_modules/effector/effector/is.ts","../node_modules/effector/effector/caller.ts","../node_modules/effector/effector/step.ts","../node_modules/effector/effector/stateRef.ts","../node_modules/effector/effector/clearNode.ts","../node_modules/effector/effector/subscription.ts","../node_modules/effector/effector/forward.ts","../node_modules/effector/effector/watch.ts","../node_modules/patronum/throttle/index.js"],"sourcesContent":["/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\tvar nativeCodeString = '[native code]';\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tif (arg.length) {\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\t\tif (inner) {\n\t\t\t\t\t\tclasses.push(inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\t\t\tclasses.push(arg.toString());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var e=require(\"react\");function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}\nfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var h=require(\"react\"),n=require(\"use-sync-external-store/shim\");function p(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q=\"function\"===typeof Object.is?Object.is:p,r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue;\nexports.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f}else f=c.current;c=v(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return[function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r(a,c[0],c[1]);\nu(function(){f.hasValue=!0;f.value=d},[d]);w(d);return d};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nexport default function _regeneratorRuntime() {\n  \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n  _regeneratorRuntime = function _regeneratorRuntime() {\n    return exports;\n  };\n  var exports = {},\n    Op = Object.prototype,\n    hasOwn = Op.hasOwnProperty,\n    defineProperty = Object.defineProperty || function (obj, key, desc) {\n      obj[key] = desc.value;\n    },\n    $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n    iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n    asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n    toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n      generator = Object.create(protoGenerator.prototype),\n      context = new Context(tryLocsList || []);\n    return defineProperty(generator, \"_invoke\", {\n      value: makeInvokeMethod(innerFn, self, context)\n    }), generator;\n  }\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n    NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n          value = result.value;\n        return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n      reject(record.arg);\n    }\n    var previousPromise;\n    defineProperty(this, \"_invoke\", {\n      value: function value(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n    });\n  }\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = \"suspendedStart\";\n    return function (method, arg) {\n      if (\"executing\" === state) throw new Error(\"Generator is already running\");\n      if (\"completed\" === state) {\n        if (\"throw\" === method) throw arg;\n        return doneResult();\n      }\n      for (context.method = method, context.arg = arg;;) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n        if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n          if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n          context.dispatchException(context.arg);\n        } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n        state = \"executing\";\n        var record = tryCatch(innerFn, self, context);\n        if (\"normal\" === record.type) {\n          if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        }\n        \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n      }\n    };\n  }\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (undefined === method) {\n      if (context.delegate = null, \"throw\" === context.method) {\n        if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel;\n        context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n      return ContinueSentinel;\n    }\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n          next = function next() {\n            for (; ++i < iterable.length;) {\n              if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n            }\n            return next.value = undefined, next.done = !0, next;\n          };\n        return next.next = next;\n      }\n    }\n    return {\n      next: doneResult\n    };\n  }\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", {\n    value: GeneratorFunctionPrototype,\n    configurable: !0\n  }), defineProperty(GeneratorFunctionPrototype, \"constructor\", {\n    value: GeneratorFunction,\n    configurable: !0\n  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (val) {\n    var object = Object(val),\n      keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {\n        \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n      }\n    },\n    stop: function stop() {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) throw exception;\n      var context = this;\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n          record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n            hasFinally = hasOwn.call(entry, \"finallyLoc\");\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import {Store, clearNode, step, createNode, Scope, Node, Cmd} from 'effector'\n\nexport function createWatch<T>(\n  store: Store<T>,\n  fn: (value: T) => any,\n  scope?: Scope,\n  batchStep?: Cmd,\n) {\n  const seq: Cmd[] = [step.run({fn: value => fn(value)})]\n  if (batchStep) seq.unshift(batchStep)\n  if (scope) {\n    const node = createNode({node: seq})\n    const id = (store as any).graphite.id\n    const scopeLinks: {[_: string]: Node[]} = (scope as any).additionalLinks\n    const links = scopeLinks[id] || []\n    scopeLinks[id] = links\n    links.push(node)\n    return () => {\n      const idx = links.indexOf(node)\n      if (idx !== -1) links.splice(idx, 1)\n      clearNode(node)\n    }\n  } else {\n    const node = createNode({\n      node: seq,\n      parent: [store],\n      family: {owners: store},\n    })\n    return () => {\n      clearNode(node)\n    }\n  }\n}\n","export function withDisplayName(name: string, Component: any) {\n  Component.displayName = name\n  return Component\n}\n","import {Store, is, step, scopeBind, Scope, Unit, Event} from 'effector'\nimport React from 'react'\nimport {useSyncExternalStore} from 'use-sync-external-store/shim'\nimport {useSyncExternalStoreWithSelector} from 'use-sync-external-store/shim/with-selector'\nimport {throwError} from './throw'\nimport {createWatch} from './createWatch'\nimport {withDisplayName} from './withDisplayName'\n\nconst stateReader = <T>(store: Store<T>, scope?: Scope) =>\n  scope ? scope.getState(store) : store.getState()\nconst basicUpdateFilter = <T>(upd: T, oldValue: T) => upd !== oldValue\nconst keysEqual = (a?: readonly any[], b?: readonly any[]) => {\n  if (!a || !b || a.length !== b.length) return false\n\n  let isEqual = true\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      isEqual = false\n      break\n    }\n  }\n\n  return isEqual\n}\n\nexport function useStoreBase<State>(store: Store<State>, scope?: Scope) {\n  if (!is.store(store)) throwError('expect useStore argument to be a store')\n\n  const subscribe = React.useCallback(\n    (cb: () => void) => createWatch(store, cb, scope),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n  const currentValue = useSyncExternalStore(subscribe, read, read)\n\n  return currentValue\n}\n\nexport function useUnitBase<Shape extends {[key: string]: Unit<any>}>(\n  shape: Shape,\n  scope?: Scope,\n) {\n  const isSingleUnit = is.unit(shape)\n  const normShape: {[key: string]: Unit<any>} = isSingleUnit\n    ? {unit: shape}\n    : shape\n  const isList = Array.isArray(normShape)\n  const flagsRef = React.useRef({\n    stale: true,\n    justSubscribed: false,\n    scope,\n  })\n  const [eventsShape, storeKeys, storeValues] = React.useMemo(() => {\n    flagsRef.current.stale = true\n    const shape = Array.isArray(normShape) ? [] : ({} as any)\n    const storeKeys: string[] = []\n    const storeValues: Array<Store<any>> = []\n    for (const key in normShape) {\n      const unit = normShape[key]\n      if (!is.unit(unit)) throwError('expect useUnit argument to be a unit')\n      if (is.event(unit) || is.effect(unit)) {\n        shape[key] = scope ? scopeBind(unit as Event<any>, {scope}) : unit\n      } else {\n        shape[key] = null\n        storeKeys.push(key)\n        storeValues.push(unit as Store<any>)\n      }\n    }\n    return [shape, storeKeys, storeValues]\n  }, [flagsRef, scope, ...Object.keys(normShape), ...Object.values(normShape)])\n  const stateRef = React.useRef({value: eventsShape, storeKeys})\n  const subscribe = React.useCallback(\n    (cb: () => void) => {\n      const flags = flagsRef.current\n      flags.justSubscribed = true\n      const cbCaller = () => {\n        if (!flags.stale) {\n          flags.stale = true\n          cb()\n        }\n      }\n      const batchStep = step.compute({priority: 'sampler', batch: true})\n      const subs = storeValues.map(store =>\n        createWatch(store, cbCaller, scope, batchStep),\n      )\n      return () => {\n        subs.forEach(fn => fn())\n      }\n    },\n    [storeValues, scope, stateRef, flagsRef],\n  )\n  const read = React.useCallback(() => {\n    const state = stateRef.current\n    const flags = flagsRef.current\n    let resultValue\n    let changed = false\n    const oldVal = state.value\n    const oldKeys = state.storeKeys\n    const scopeChanged = scope !== flags.scope\n    if (\n      (storeKeys.length > 0 || oldKeys.length > 0) &&\n      (flags.stale || flags.justSubscribed || scopeChanged)\n    ) {\n      changed = !flags.justSubscribed || scopeChanged\n      resultValue = isList ? [...eventsShape] : {...eventsShape}\n      if (oldKeys.length !== storeKeys.length) {\n        changed = true\n      }\n      for (let i = 0; i < storeKeys.length; i++) {\n        const updatedValue = stateReader(storeValues[i], scope)\n        const key = storeKeys[i]\n        if (!changed) {\n          if (!oldKeys.includes(key)) {\n            changed = true\n          } else {\n            changed = oldVal[key] !== updatedValue\n          }\n        }\n        resultValue[key] = updatedValue\n      }\n    }\n    if (changed) {\n      state.value = resultValue\n    }\n    state.storeKeys = storeKeys\n    flags.stale = false\n    flags.justSubscribed = !changed\n    flags.scope = scope\n    return isSingleUnit ? state.value.unit : state.value\n  }, [subscribe, storeValues, scope, stateRef, flagsRef])\n  return useSyncExternalStore(subscribe, read, read)\n}\n\nexport function useStoreMapBase<State, Result, Keys extends ReadonlyArray<any>>(\n  [configOrStore, separateFn]: [\n    configOrStore:\n      | {\n          store: Store<State>\n          keys: Keys\n          fn(state: State, keys: Keys): Result\n          updateFilter?: (update: Result, current: Result) => boolean\n          defaultValue?: Result\n        }\n      | Store<State>,\n    separateFn?: (state: State, keys: Keys) => Result,\n  ],\n  scope?: Scope,\n): Result {\n  let fn: (state: State, keys: Keys) => Result\n  let updateFilter: (update: Result, current: Result) => boolean =\n    basicUpdateFilter\n  let defaultValue: Result | undefined\n  let store: Store<State>\n  let keys: Keys\n  if (separateFn) {\n    fn = separateFn\n    store = configOrStore as Store<State>\n    keys = [] as unknown as Keys\n  } else {\n    ;({\n      fn,\n      store,\n      keys,\n      defaultValue,\n      updateFilter = basicUpdateFilter,\n    } = configOrStore as any)\n  }\n  if (!is.store(store)) throwError('useStoreMap expects a store')\n  if (!Array.isArray(keys)) throwError('useStoreMap expects an array as keys')\n  if (typeof fn !== 'function') throwError('useStoreMap expects a function')\n\n  const subscribe = React.useCallback(\n    (cb: () => void) => createWatch(store, cb, scope),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n\n  const stateRef = React.useRef<State>()\n  const valueRef = React.useRef<Result>()\n  const keysRef = React.useRef(keys)\n\n  const value = useSyncExternalStoreWithSelector(\n    subscribe,\n    read,\n    read,\n    state => {\n      if (stateRef.current !== state || !keysEqual(keysRef.current, keys)) {\n        let result = fn(state, keys)\n        if (result === undefined && defaultValue !== undefined) {\n          result = defaultValue\n        }\n        stateRef.current = state\n        keysRef.current = keys\n\n        /**\n         * skip update, if undefined\n         * just like original store or previous implementation\n         */\n        if (result !== undefined) {\n          valueRef.current = result\n        }\n      }\n\n      return valueRef.current as Result\n    },\n    (current, update) => !updateFilter(update, current),\n  )\n\n  return value\n}\nexport function useListBase<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  scope?: Scope,\n): React.ReactNode {\n  let keys = [] as any[]\n  let fn\n  let getKey: ((item: T) => string) | void\n  let placeholder: React.ReactNode | void\n  if (typeof renderItem === 'object' && renderItem !== null) {\n    if (renderItem.keys) keys = renderItem.keys\n    ;({fn, getKey, placeholder} = renderItem)\n  } else {\n    fn = renderItem\n  }\n  if (!is.store(list)) throwError('expect useList first argument to be a store')\n  if (typeof fn !== 'function')\n    throwError(\"expect useList's renderItem to be a function\")\n  if (!Array.isArray(keys)) throwError(\"expect useList's keys to be an array\")\n  const Item = React.useMemo(() => {\n    const Item = withDisplayName(\n      `${list.shortName || 'Unknown'}.Item`,\n      (\n        props:\n          | {index: number; keys: any[]; keyVal: never; value: never}\n          | {index: never; keys: any[]; keyVal: string; value: T},\n      ) => {\n        const {index, keys, keyVal, value} = props\n        const isKeyed = !!fnRef.current[1]\n        if (isKeyed) {\n          return fnRef.current[0](value, keyVal as any)\n        }\n        const item = useStoreMapBase(\n          [\n            {\n              store: list,\n              keys: [index, ...keys],\n              fn: (list, keys) => list[keys[0]],\n            },\n          ],\n          scope,\n        )\n        return fnRef.current[0](item, index)\n      },\n    )\n    return React.memo(Item)\n  }, [list, scope, !!getKey!])\n  const fnRef = React.useRef([fn, getKey!] as const)\n  fnRef.current = [fn, getKey!]\n  const keysSelfMemo = React.useMemo(() => keys, keys)\n  if (getKey!) {\n    const listItems = useStoreBase(list, scope)\n    if (listItems.length === 0 && placeholder) return placeholder\n    return listItems.map(value => {\n      const key = fnRef.current[1](value)\n      return React.createElement(Item, {\n        keyVal: key,\n        key,\n        keys: keysSelfMemo,\n        value,\n      })\n    })\n  } else {\n    const length = useStoreMapBase(\n      [\n        {\n          store: list,\n          keys: [list],\n          fn: list => list.length,\n        },\n      ],\n      scope,\n    )\n    if (length === 0 && placeholder) return placeholder\n    return Array.from({length}, (_, i) =>\n      React.createElement(Item, {\n        index: i,\n        key: i,\n        keys: keysSelfMemo,\n      }),\n    )\n  }\n}\n\nexport function useEventBase(eventObject: any, scope?: Scope) {\n  if (!scope) {\n    return eventObject\n  }\n  const isShape = !is.unit(eventObject) && typeof eventObject === 'object'\n  const events = isShape ? eventObject : {event: eventObject}\n\n  return React.useMemo(() => {\n    if (is.unit(eventObject)) {\n      //@ts-expect-error\n      return scopeBind(eventObject, {scope})\n    }\n    const shape = Array.isArray(eventObject) ? [] : ({} as any)\n    for (const key in eventObject) {\n      shape[key] = scopeBind(eventObject[key], {scope})\n    }\n    return shape\n  }, [scope, ...Object.keys(events), ...Object.values(events)])\n}\n","import React from 'react'\nimport {Scope} from 'effector'\nimport {throwError} from './throw'\n\nconst ScopeContext = React.createContext(null as Scope | null)\nexport const {Provider} = ScopeContext\nexport function getScope(forceScope?: boolean) {\n  const scope = React.useContext(ScopeContext)\n  if (forceScope && !scope)\n    throwError('No scope found, consider adding <Provider> to app root')\n  return scope as Scope\n}\n","import {Event, Store} from 'effector'\nimport {\n  useStoreBase,\n  useStoreMapBase,\n  useListBase,\n  useUnitBase,\n  useEventBase,\n} from './apiBase'\nimport {getScope} from './scope'\n\n/**\nbind event to scope\n\nworks like React.useCallback, but for scopes\n*/\nexport function useEvent<T>(\n  event: Event<T>,\n  opts?: {forceScope?: boolean},\n): (payload: T) => T {\n  const scope = getScope(opts?.forceScope)\n\n  return useEventBase(event, scope)\n}\n\nexport function useStore<State>(\n  store: Store<State>,\n  opts?: {forceScope?: boolean},\n): State {\n  return useStoreBase(store, getScope(opts?.forceScope))\n}\n\nexport function useUnit(shape, opts?: {forceScope?: boolean}) {\n  return useUnitBase(shape, getScope(opts?.forceScope))\n}\n\nexport function useStoreMap<State, Result, Keys extends ReadonlyArray<any>>(\n  configOrStore:\n    | {\n        store: Store<State>\n        keys: Keys\n        fn(state: State, keys: Keys): Result\n        updateFilter?: (update: Result, current: Result) => boolean\n        defaultValue?: Result\n        forceScope?: boolean\n      }\n    | Store<State>,\n  separateFn?: (state: State, keys: Keys) => Result,\n): Result {\n  return useStoreMapBase(\n    [configOrStore, separateFn],\n    getScope(configOrStore?.forceScope),\n  )\n}\n\nexport function useList<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  opts?: {forceScope?: boolean},\n): React.ReactNode {\n  return useListBase(list, renderItem, getScope(opts?.forceScope))\n}\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","import React from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n","export function forIn<T, Key extends string = string>(\n  obj: Record<Key, T>,\n  cb: (value: T, key: Key) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","export function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n) =>\n  !condition &&\n  console.error(\n    `${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n","import type {Node, NodeUnit, Cmd} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\nimport {add, forEach} from './collection'\n\nexport const arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => (Array.isArray(list) ? list : [list]).flat().map(getGraph)\n\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  forEach(node, item => item && add(seq, item))\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n  }\n  forEach(links, link => add(getOwners(link), result))\n  forEach(owners, owner => add(getLinks(owner), result))\n  forEach(sources, source => add(source.next, result))\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SCOPE = 'scope'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import type {Leaf} from '../forest/index.h'\n\nimport type {Node, NodeUnit, StateRef, Stack} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getMeta, getParent, getValue} from './getter'\nimport {STORE, EFFECT, SAMPLER, STACK, BARRIER, VALUE, REG_A, MAP} from './tag'\nimport type {Scope} from './unit.h'\nimport {add, forEach} from './collection'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'read' | 'barrier' | 'sampler' | 'effect'\n\nexport type BarrierPriorityTag = 'read' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (a.v.type === b.v.type && a.v.id > b.v.id) ||\n    /**\n     * greater priority mean bucket of first node is executed later\n     * e.g  a: \"sampler\", b: \"barrier\"\n     */\n    getPriority(a.v.type) > getPriority(b.v.type)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 6) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  add(queue, {first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 6; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * bucket 3 is for \"barrier\" PriorityType (used in combine)\n       * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 3 || i === 4) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: Leaf | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  scope?: Scope | null | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      scope,\n    },\n    type,\n  )\nconst pushHeap = (\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number = 0,\n) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: null,\n    r: null,\n  }\n  /**\n   * bucket 3 is for \"barrier\" PriorityType (used in combine)\n   * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 3 || priority === 4) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'read':\n      return 2\n    case BARRIER:\n      return 3\n    case SAMPLER:\n      return 4\n    case EFFECT:\n      return 5\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set<string | number>()\n\nlet isRoot = true\nexport let isWatch = false\nexport let isPure = false\nexport let currentPage: Leaf | null = null\nexport let forkPage: Scope | void | null\nexport const setForkPage = (newForkPage: Scope | void | null) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: Leaf | null) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: Leaf | null, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nexport const getPageRef = (\n  page: Leaf | null,\n  forkPage: Scope | null | void,\n  node: Node | null,\n  ref: StateRef,\n  isGetState?: boolean,\n) => {\n  const pageForRef = getPageForRef(page, ref.id)\n  if (pageForRef) return pageForRef.reg[ref.id]\n  if (forkPage) {\n    initRefInScope(forkPage!, ref, isGetState)\n    return forkPage.reg[ref.id]\n  }\n  return ref\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: Leaf | void | null\n  scope?: Scope | void\n  stack?: Stack | void\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {\n    isRoot,\n    currentPage,\n    scope: forkPage,\n    isWatch,\n    isPure,\n  }\n  isRoot = false\n  let stop: boolean\n  let skip: boolean\n  let node: Node\n  let value: Layer | undefined\n  let page: Leaf | null\n  let reg: Record<string, StateRef> | void\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    if (page) reg = page.reg\n    else if (forkPage) reg = forkPage.reg\n    // reg = (page ? page : forkPage ? forkPage : node).reg\n    const hasPageReg = !!page\n    const hasScopeReg = !!forkPage\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      if (step.order) {\n        const {priority, barrierID} = step.order\n        const id = barrierID\n          ? page\n            ? `${page.fullID}_${barrierID}`\n            : barrierID\n          : 0\n        if (stepn !== idx || type !== priority) {\n          if (barrierID) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, barrierID)\n            }\n          } else {\n            pushHeap(stepn, stack, priority)\n          }\n          continue kernelLoop\n        }\n        barrierID && barriers.delete(id)\n      }\n      switch (step.type) {\n        case 'mov': {\n          const data = step.data\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (reg && !reg[data.store.id]) {\n                // if (!page.parent) {\n                if (hasPageReg) {\n                  const pageForRef = getPageForRef(page, data.store.id)\n                  stack.page = page = pageForRef\n                  if (pageForRef) {\n                    reg = pageForRef.reg\n                  } else if (hasScopeReg) {\n                    initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                    reg = forkPage!.reg\n                  } else {\n                    reg = undefined //node.reg\n                  }\n                } else if (hasScopeReg) {\n                  /** StateRef in Scope.reg created only when needed */\n                  initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                } else {\n                  // console.error('should not happen')\n                  /** StateRef should exists at least in Node itself, but it is not found */\n                }\n                // }\n              }\n              // value = getPageRef(page, forkPage, node, data.store.id).current\n              value = readRef(reg ? reg[data.store.id] || data.store : data.store)\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, forkPage, node, data.target).current = value\n              break\n          }\n          break\n        }\n        case 'compute':\n          const data = step.data\n          if (data.fn) {\n            isWatch = getMeta(node, 'op') === 'watch'\n            isPure = data.pure\n            const computationResult = data.safe\n              ? (0 as any, data.fn)(getValue(stack), local.scope, stack)\n              : tryRun(local, data.fn, stack)\n            if (data.filter) {\n              /**\n               * handled edge case: if step.fn will throw,\n               * tryRun will return null\n               * thereby forcing that branch to stop\n               */\n              skip = !computationResult\n            } else {\n              stack.value = computationResult\n            }\n            isWatch = lastStartedState.isWatch\n            isPure = lastStartedState.isPure\n          }\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      const finalValue = getValue(stack)\n      const forkPage = getForkPage(stack)\n      forEach(node.next, nextNode => {\n        pushFirstHeapItem('child', page, nextNode, stack, finalValue, forkPage)\n      })\n      if (forkPage) {\n        if (getMeta(node, 'needFxCounter'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.fxCount,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'storeChange'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.storeChange,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'warnSerialize'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.warnSerializeNode,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        const additionalLinks = forkPage.additionalLinks[node.id]\n        if (additionalLinks) {\n          forEach(additionalLinks, nextNode => {\n            pushFirstHeapItem(\n              'child',\n              page,\n              nextNode,\n              stack,\n              finalValue,\n              forkPage,\n            )\n          })\n        }\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\nconst noopParser = (x: any) => x\n\nexport const initRefInScope = (\n  scope: {\n    reg: Record<string, StateRef>\n    sidValuesMap: Record<string, any>\n    sidIdMap: Record<string, string>\n    fromSerialize?: boolean\n  },\n  sourceRef: StateRef,\n  isGetState?: boolean,\n  isKernelCall?: boolean,\n  softRead?: boolean,\n) => {\n  const refsMap = scope.reg\n  const sid = sourceRef.sid\n  const serialize = sourceRef?.meta?.serialize\n  const parser =\n    scope.fromSerialize && serialize !== 'ignore'\n      ? serialize?.read || noopParser\n      : noopParser\n  if (refsMap[sourceRef.id]) return\n  const ref: StateRef = {\n    id: sourceRef.id,\n    current: sourceRef.current,\n    meta: sourceRef.meta,\n  }\n\n  if (sid && sid in scope.sidValuesMap && !(sid in scope.sidIdMap)) {\n    ref.current = parser(scope.sidValuesMap[sid])\n  } else {\n    if (sourceRef.before && !softRead) {\n      let isFresh = false\n      const needToAssign = isGetState || !sourceRef.noInit || isKernelCall\n      forEach(sourceRef.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            if (from || cmd.fn) {\n              if (from) initRefInScope(scope, from, isGetState, isKernelCall)\n              const value = from && refsMap[from.id].current\n              if (needToAssign) {\n                ref.current = cmd.fn ? cmd.fn(value) : value\n              }\n            }\n            break\n          }\n          case 'field': {\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            initRefInScope(scope, cmd.from, isGetState, isKernelCall)\n            if (needToAssign) {\n              const from = refsMap[cmd.from.id]\n              ref.current[cmd.field] = refsMap[from.id].current\n            }\n            break\n          }\n          // case 'closure':\n          //   break\n        }\n      })\n    }\n  }\n  if (sid) scope.sidIdMap[sid] = sourceRef.id\n  refsMap[sourceRef.id] = ref\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, fn: Function, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","import type {Store, CommonUnit, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent, getCompositeName} from './getter'\nimport {forIn} from './collection'\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  forIn(objOrArr, unit => {\n    /* inlined max object names constant */\n    if (i < 25) {\n      if (unit != null) {\n        name += comma\n        name += is.unit(unit)\n          ? getCompositeName(unit as CommonUnit | Domain).fullName\n          : (unit as any).toString()\n      }\n      i += 1\n      comma = ', '\n    }\n  })\n  return name + ')'\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  store.shortName = rawName\n  Object.assign(getCompositeName(store), createName(rawName, getParent(store)))\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  const shortName = name\n  if (!parent) {\n    path = name.length === 0 ? [] : [name]\n    fullName = name\n  } else {\n    const composite = getCompositeName(parent)\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      fullName =\n        composite.fullName.length === 0\n          ? name\n          : '' + composite.fullName + '/' + name\n    }\n  }\n  return {shortName, fullName, path}\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any[],\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: Record<string, any> = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","import {readTemplate} from './region'\nimport type {Template, TemplateHandlers} from '../forest/index.h'\n\nexport function applyTemplate<K extends keyof TemplateHandlers>(\n  method: K,\n  ...args: Parameters<TemplateHandlers[K]> extends [Template, ...infer Args]\n    ? Args\n    : never\n): ReturnType<TemplateHandlers[K]> | void {\n  const template = readTemplate()\n  if (template) {\n    const fn = template.handlers[method]\n    // @ts-expect-error\n    if (fn) return fn(template, ...args)\n  }\n}\n","import type {Template} from '../forest/index.h'\nimport type {Store, Event, CommonUnit, Effect, Domain} from './unit.h'\nimport type {Subscriber, Config, Cmd, Kind} from './index.h'\n\nimport {observableSymbol} from './observable'\n\nimport {\n  is,\n  isObject,\n  isFunction,\n  assertObject,\n  assertNodeSet,\n  isVoid,\n} from './is'\nimport {calc, mov, read, userFnCall} from './step'\nimport {createStateRef, readRef, addRefOp} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {\n  launch,\n  currentPage,\n  forkPage,\n  setCurrentPage,\n  initRefInScope,\n  isPure,\n} from './kernel'\n\nimport {createName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot} from './region'\nimport {\n  getSubscribers,\n  getStoreState,\n  getGraph,\n  getParent,\n  setMeta,\n  getMeta,\n} from './getter'\nimport {assert, deprecate} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, STACK, REG_A} from './tag'\nimport {applyTemplate} from './template'\nimport {forEach} from './collection'\nimport {flattenConfig} from './config'\n\nexport const applyParentHook = (\n  source: CommonUnit,\n  target: CommonUnit,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nexport const initUnit = (kind: Kind, unit: any, rawConfig: any) => {\n  const config = flattenConfig(rawConfig)\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  const {sid = null, named = null, domain = null, parent = domain} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n  const meta: Record<string, any> = {\n    op: (unit.kind = kind),\n    name: (unit.shortName = name),\n    sid: (unit.sid = readSidRoot(sid)),\n    named,\n    unitId: (unit.id = id),\n    serialize: config.serialize,\n    derived: config.derived,\n    config,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => {\n    deprecate(false, 'thru', 'js pipe')\n    return fn(unit)\n  }\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => observer.next && observer.next(upd),\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst deriveEvent = (\n  event: Event<any>,\n  op: 'map' | 'filterMap' | 'filter',\n  fn: Function,\n  node: Cmd[],\n) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = (fn as unknown as {fn: Function}).fn\n  }\n  const mapped = createEvent({\n    name: `${event.shortName}  *`,\n    derived: true,\n    and: config,\n  })\n  createLinkNode(event, mapped, node, op, fn)\n  return mapped\n}\n\nfunction callCreate<T>(\n  unit: Event<T> | Effect<T, any, any>,\n  template: Template | null,\n  payload: T,\n  args: any[],\n) {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: typeof nameOrConfig === 'string' ? {name: nameOrConfig} : nameOrConfig,\n  }) as any\n  const event = ((payload: Payload, ...args: unknown[]) => {\n    deprecate(\n      !getMeta(event, 'derived'),\n      'call of derived event',\n      'createEvent',\n    )\n    deprecate(!isPure, 'unit call from pure function', 'operators like sample')\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }) as Event<Payload>\n  const template = readTemplate()\n  const finalEvent = Object.assign(event, {\n    graphite: createNode({\n      meta: initUnit(EVENT, event, config),\n      regional: true,\n    }),\n    create(params: Payload, _: any[]) {\n      launch({target: event, params, scope: forkPage!})\n      return params\n    },\n    watch: (fn: (payload: Payload) => any) => watchUnit(event, fn),\n    map: (fn: Function) => deriveEvent(event, MAP, fn, [userFnCall()]),\n    filter: (fn: {fn: Function}) =>\n      //@ts-expect-error\n      deriveEvent(event, FILTER, fn.fn ? fn : fn.fn, [\n        userFnCall(callStack, true),\n      ]),\n    filterMap: (fn: Function) =>\n      deriveEvent(event, 'filterMap', fn, [\n        userFnCall(),\n        calc(value => !isVoid(value), true),\n      ]),\n    prepend(fn: Function) {\n      const contramapped: Event<any> = createEvent('*  ' + event.shortName, {\n        parent: getParent(event),\n      })\n      applyTemplate('eventPrepend', getGraph(contramapped))\n      createLinkNode(contramapped, event, [userFnCall()], 'prepend', fn)\n      applyParentHook(event, contramapped)\n      return contramapped\n    },\n  })\n  if (config?.domain) {\n    config.domain.hooks.event(finalEvent)\n  }\n  return finalEvent\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const config = flattenConfig(props)\n  const plainState = createStateRef(defaultState)\n  const updates = createEvent({named: 'updates', derived: true})\n  applyTemplate('storeBase', plainState)\n  const plainStateId = plainState.id\n  const store = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage) {\n        initRefInScope(forkPage, plainState, true)\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState: (state: State) =>\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n        scope: forkPage!,\n      }),\n    reset(...units: CommonUnit[]) {\n      forEach(units, unit => store.on(unit, () => store.defaultState))\n      return store\n    },\n    on(nodeSet: CommonUnit | CommonUnit[], fn: Function) {\n      assertNodeSet(nodeSet, '.on', 'first argument')\n      assert(isFunction(fn), 'second argument should be a function')\n      deprecate(\n        !getMeta(store, 'derived'),\n        '.on in derived store',\n        'createStore',\n      )\n      forEach(Array.isArray(nodeSet) ? nodeSet : [nodeSet], trigger => {\n        store.off(trigger)\n        getSubscribers(store).set(\n          trigger,\n          createSubscription(\n            updateStore(trigger, store, 'on', callARegStack, fn),\n          ),\n        )\n      })\n      return store\n    },\n    off(unit: CommonUnit) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: (value: any, prevArg?: any) => any, firstState?: any) {\n      let config\n      if (isObject(fn)) {\n        config = fn\n        fn = (fn as unknown as {fn: (value: any) => any}).fn\n      }\n      deprecate(\n        isVoid(firstState),\n        'second argument of store.map',\n        'updateFilter',\n      )\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (!isVoid(storeState)) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: `${store.shortName}  *`,\n        derived: true,\n        // @ts-expect-error some mismatch in config types\n        and: config,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, callStackAReg, fn)\n      addRefOp(getStoreState(innerStore), {\n        type: MAP,\n        fn,\n        from: plainState,\n      })\n      getStoreState(innerStore).noInit = true\n      applyTemplate('storeMap', plainState, linkNode)\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        if (!applyTemplate('storeWatch', plainState, eventOrFn)) {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      assert(isFunction(fn), 'second argument should be a function')\n      return (eventOrFn as CommonUnit).watch((payload: any) =>\n        fn(store.getState(), payload),\n      )\n    },\n  } as unknown as Store<State>\n  const meta = initUnit(STORE, store, config)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState, fn: updateFilter},\n    node: [\n      calc((upd, _, stack) => {\n        if (stack.scope && !stack.scope.reg[plainState.id]) {\n          stack.b = true\n        }\n        return upd\n      }),\n      read(plainState),\n      calc((upd, _, {a, b}) => !isVoid(upd) && (upd !== a || b), true),\n      updateFilter && userFnCall(callStackAReg, true),\n      mov({from: STACK, target: plainState}),\n    ],\n    child: updates,\n    meta,\n    regional: true,\n  })\n  const serializeMeta = getMeta(store, 'serialize')\n  const derived = getMeta(store, 'derived')\n  const ignored = serializeMeta === 'ignore'\n  const customSerialize = !serializeMeta || ignored ? false : serializeMeta\n  const sid: string | null = getMeta(store, 'sid')\n  if (sid) {\n    if (!ignored) setMeta(store, 'storeChange', true)\n    plainState.sid = sid\n\n    if (customSerialize) {\n      plainState.meta = {\n        ...plainState?.meta,\n        serialize: customSerialize,\n      }\n    }\n  }\n  if (!sid && !ignored && !derived) {\n    setMeta(store, 'warnSerialize', true)\n  }\n  assert(\n    derived || !isVoid(defaultState),\n    \"current state can't be undefined, use null instead\",\n  )\n  own(store, [updates])\n  if (config?.domain) {\n    config.domain.hooks.store(store)\n  }\n\n  if (!derived) {\n    store.reinit = createEvent<void>();\n    store.reset(store.reinit);\n  }\n\n  return store\n}\n\nconst updateStore = (\n  from: CommonUnit,\n  store: Store<any>,\n  op: string,\n  caller: typeof callStackAReg,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const reader = mov({\n    store: storeRef,\n    to: REG_A,\n    priority: 'read',\n  })\n  if (op === MAP) reader.data.softRead = true\n  const node = [reader, userFnCall(caller)]\n  applyTemplate(\n    'storeOnMap',\n    storeRef,\n    node,\n    is.store(from) && getStoreState(from),\n  )\n  return createLinkNode(from, store, node, op, fn)\n}\n","import type {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef, addRefOp} from './stateRef'\nimport {mov, calc, read, userFnCall} from './step'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, setMeta} from './getter'\nimport {is, isFunction, isObject, isVoid} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {assert, deprecate} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\nimport {applyTemplate} from './template'\nimport type {Config} from './index.h'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  ;[args, config] = processArgsToConfig(args)\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  let noArraySpread: boolean | void\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      noArraySpread = true\n      const fn = handler\n      handler = (list: any[]) => fn(...list)\n    }\n  }\n  assert(isObject(structStoreShape), 'shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    !noArraySpread,\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst storeCombination = (\n  isArray: boolean,\n  needSpread: boolean,\n  obj: any,\n  config?: Config,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => [...list] : (obj: any) => ({...obj})\n  const defaultState: Record<string, any> = isArray ? [] : {}\n\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  rawShape.noInit = true\n  applyTemplate('combineBase', rawShape, isFresh)\n  const store = createStore(stateNew, {\n    name: unitObjectName(obj),\n    derived: true,\n    and: config,\n  })\n  const storeStateRef = getStoreState(store)\n  storeStateRef.noInit = true\n  setMeta(store, 'isCombine', true)\n  const rawShapeReader = read(rawShape)\n  /**\n   * usual ref reading has very high priority, which leads to data races\n   * ref reading for combine should have same \"barrier\" priority but without batching\n   * (thats why order has no \"barrierID\" field, which assume batching)\n   **/\n  rawShapeReader.order = {priority: 'barrier'}\n  const node = [\n    calc((upd, _, stack) => {\n      if (stack.scope && !stack.scope.reg[rawShape.id]) {\n        stack.c = true\n      }\n      return upd\n    }),\n    rawShapeReader,\n    mov({store: isFresh, to: 'b'}),\n    calc((upd, {key}, reg) => {\n      if (reg.c || upd !== reg.a[key]) {\n        if (needSpread && reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n        return true\n      }\n    }, true),\n    mov({from: REG_A, target: rawShape}),\n    mov({from: VALUE, store: false, target: isFresh}),\n    mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n      priority: BARRIER,\n      batch: true,\n    }),\n    read(rawShape, true),\n    fn && userFnCall(),\n  ]\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      assert(\n        !is.unit(child) && !isVoid(child),\n        `combine expects a store in a field ${key}`,\n      )\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, node, 'combine', fn)\n    linkNode.scope.key = key\n    const childRef = getStoreState(child)\n    addRefOp(rawShape, {type: 'field', field: key, from: childRef})\n    applyTemplate('combineField', childRef, linkNode)\n  })\n\n  store.defaultShape = obj\n  addRefOp(storeStateRef, {\n    type: MAP,\n    from: rawShape,\n    fn,\n  })\n  if (!readTemplate()) {\n    store.defaultState = fn\n      ? (storeStateRef.current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n\nexport function createStoreObject(...args: any[]) {\n  deprecate(false, 'createStoreObject', 'combine')\n  return combine(...args)\n}\n","import type {Defer} from './unit.h'\n\nexport function createDefer(): Defer {\n  const result = {} as Defer\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(() => {})\n  return result\n}\n","import type {Unit, Stack} from './index.h'\nimport type {Effect, Scope} from './unit.h'\nimport {calc, run} from './step'\nimport {getForkPage, getGraph, getMeta, getParent, setMeta} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch} from './kernel'\nimport {createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {assert} from './throw'\nimport {EFFECT} from './tag'\nimport {add, removeItem} from './collection'\nimport {flattenConfig} from './config'\n\ntype RunnerData<Params, Done, Fail> = {\n  params: Params\n  req: {\n    rs(data: Done): void\n    rj(data: Fail): void\n  }\n  args?: [params: Params, computedParams: any] | [params: Params]\n  handler?: Function\n}\n\nexport function createEffect<Params, Done, Fail = Error>(\n  nameOrConfig: any,\n  maybeConfig?: any,\n): Effect<Params, Done, Fail> {\n  const config = flattenConfig(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    maybeConfig,\n  )\n  const instance = createEvent(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    maybeConfig,\n  ) as unknown as Effect<Params, Done, Fail>\n  const node = getGraph(instance)\n  setMeta(node, 'op', (instance.kind = EFFECT))\n  //@ts-expect-error\n  instance.use = (fn: Function) => {\n    assert(isFunction(fn), '.use argument should be a function')\n    runner.scope.handler = fn\n    return instance\n  }\n  instance.use.getCurrent = () => runner.scope.handler\n  const anyway = (instance.finally = createEvent({\n    named: 'finally',\n    derived: true,\n  }))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({\n      status,\n      params,\n      result,\n    }: {\n      status: 'done' | 'fail'\n      params: Params\n      result: Done\n      error: Fail\n    }) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({\n      status,\n      params,\n      error,\n    }: {\n      status: 'done' | 'fail'\n      params: Params\n      result: Done\n      error: Fail\n    }) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: {result: Done}) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: {error: Fail}) => error,\n  }))\n\n  const runner = createNode({\n    scope: {\n      handlerId: getMeta(node, 'sid'),\n      handler:\n        instance.defaultConfig.handler ||\n        (() => assert(false, `no handler used in ${instance.getType()}`)),\n    },\n    node: [\n      calc(\n        (upd: RunnerData<Params, Done, Fail>, scope_, stack) => {\n          const scope: {handlerId: string; handler: Function} = scope_ as any\n          let handler = scope.handler\n          if (getForkPage(stack)) {\n            const handler_ = getForkPage(stack)!.handlers[scope.handlerId]\n            if (handler_) handler = handler_\n          }\n          upd.handler = handler\n          return upd\n        },\n        false,\n        true,\n      ),\n      calc(\n        (\n          {\n            params,\n            req,\n            handler,\n            args = [params],\n          }: RunnerData<Params, Done, Fail> & {handler: Function},\n          _,\n          stack,\n        ) => {\n          const scopeRef = createScopeRef(stack)\n          const onResolve = onSettled(\n            params,\n            req,\n            true,\n            anyway,\n            stack,\n            scopeRef,\n          )\n          const onReject = onSettled(\n            params,\n            req,\n            false,\n            anyway,\n            stack,\n            scopeRef,\n          )\n          const [ok, result] = runFn(handler, onReject, args)\n          if (ok) {\n            if (isObject(result) && isFunction(result.then)) {\n              result.then(onResolve, onReject)\n            } else {\n              onResolve(result)\n            }\n          }\n        },\n        false,\n        true,\n      ),\n    ],\n    meta: {op: 'fx', fx: 'runner'},\n  })\n  node.scope.runner = runner\n  add(\n    node.seq,\n    calc(\n      (params, {runner}, stack) => {\n        const upd: RunnerData<Params, Done, Fail> = getParent(stack)\n          ? {params, req: {rs(data: Done) {}, rj(data: Fail) {}}}\n          : /** empty stack means that this node was launched directly */\n            params\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          scope: getForkPage(stack),\n        })\n        return upd.params\n      },\n      false,\n      true,\n    ),\n  )\n  //@ts-expect-error\n  instance.create = (params: Params) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n      launch({target: instance, params: payload, scope: forkPage})\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {\n    serialize: 'ignore',\n  })\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1)\n    .map({\n      // @ts-expect-error\n      fn: x => x,\n      named: 'inFlight',\n    }))\n  setMeta(anyway, 'needFxCounter', 'dec')\n  setMeta(instance, 'needFxCounter', true)\n  const pending = (instance.pending = inFlight.map({\n    //@ts-expect-error\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [anyway, done, fail, doneData, failData, pending, inFlight])\n  if (config?.domain) {\n    config.domain.hooks.effect(instance)\n  }\n  return instance\n}\nexport const runFn = (\n  fn: Function,\n  onReject: (data: any) => void,\n  args: any[],\n): [boolean, any] => {\n  try {\n    return [true, fn(...args)]\n  } catch (err) {\n    onReject(err)\n    return [false, null]\n  }\n}\n\nexport const createScopeRef = (stack: Stack) => {\n  const scope = getForkPage(stack)\n  const scopeRef = {ref: scope}\n  if (scope) add(scope.activeEffects, scopeRef)\n  return scopeRef\n}\n\nexport const onSettled =\n  (\n    params: any,\n    req: {\n      rs(_: any): void\n      rj(_: any): void\n    },\n    ok: boolean,\n    anyway: Unit,\n    stack: Stack,\n    scopeRef: {ref: Scope | void},\n  ) =>\n  (data: any) => {\n    if (scopeRef.ref) removeItem(scopeRef.ref.activeEffects, scopeRef)\n    launch({\n      target: [anyway, sidechain],\n      params: [\n        ok\n          ? {status: 'done', params, result: data}\n          : {status: 'fail', params, error: data},\n        {value: data, fn: ok ? req.rs : req.rj},\n      ],\n      defer: true,\n      // WARN! Will broke forest pages as they arent moved to new scope\n      page: stack.page,\n      scope: scopeRef.ref,\n    })\n  }\nconst sidechain = createNode({\n  node: [run({fn: ({fn, value}) => fn(value)})],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import type {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  units: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  assertNodeSet(units, 'merge', 'first argument')\n  const result = createEvent({\n    name: unitObjectName(units, 'merge'),\n    derived: true,\n    and: config,\n  })\n  createLinkNode(units, result, [], 'merge')\n  return result\n}\n","import type {Cmd, StateRef} from './index.h'\nimport type {CommonUnit, DataCarrier} from './unit.h'\nimport {combine} from './combine'\nimport {mov, userFnCall, read, calc} from './step'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {\n  assertNodeSet,\n  assertTarget,\n  is,\n  isObject,\n  isVoid,\n  isFunction,\n} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createNode} from './createNode'\nimport {assert} from './throw'\nimport {forEach} from './collection'\nimport {SAMPLE, STACK, VALUE} from './tag'\nimport {merge} from './merge'\nimport {applyTemplate} from './template'\nimport {own} from './own'\nimport {createLinkNode} from './forward'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nconst fieldErrorMessage = (method: string, field: string) =>\n  method + `: ${field} should be defined`\n\nexport function validateSampleConfig(config: any, method: string) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      assert(config[field] != null, fieldErrorMessage(method, field))\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args: any[]) {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let batched = true\n  let filter\n  /** config case */\n  if (\n    isVoid(clock) &&\n    isObject(source) &&\n    validateSampleConfig(source, SAMPLE)\n  ) {\n    clock = source.clock\n    fn = source.fn\n    batched = !source.greedy\n    filter = source.filter\n    /** optional target & name accepted only from config */\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  return createSampling(\n    SAMPLE,\n    clock,\n    source,\n    filter,\n    target,\n    fn,\n    name,\n    metadata,\n    batched,\n    true,\n    false,\n    sid,\n  )\n}\n\nexport const createSampling = (\n  method: string,\n  clock: DataCarrier | DataCarrier[] | void,\n  source: DataCarrier | Array<Store<any>> | Record<string, Store<any>> | void,\n  filter: any,\n  target: DataCarrier | DataCarrier[] | void,\n  fn: any,\n  name: string | undefined,\n  metadata: object | void,\n  batched: boolean,\n  targetMayBeStore: boolean,\n  filterRequired: boolean,\n  sid?: string | undefined,\n) => {\n  const isUpward = !!target\n  assert(\n    !isVoid(source) || !isVoid(clock),\n    fieldErrorMessage(method, 'either source or clock'),\n  )\n  let sourceIsClock = false\n  if (isVoid(source)) {\n    sourceIsClock = true\n  } else if (!is.unit(source)) {\n    source = combine(source)\n  }\n  if (isVoid(clock)) {\n    /** still undefined! */\n    clock = source\n  } else {\n    assertNodeSet(clock, method, 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock as CommonUnit[])\n    }\n  }\n  if (sourceIsClock) {\n    source = clock\n  }\n  // @ts-expect-error\n  if (!metadata && !name) name = source.shortName\n  let filterType: 'none' | 'unit' | 'fn' = 'none'\n  if (filterRequired || filter) {\n    if (is.unit(filter)) {\n      filterType = 'unit'\n    } else {\n      assert(isFunction(filter), '`filter` should be function or unit')\n      filterType = 'fn'\n    }\n  }\n  if (target) {\n    assertNodeSet(target, method, 'target')\n    assertTarget(method, target)\n  } else {\n    if (\n      filterType === 'none' &&\n      targetMayBeStore &&\n      is.store(source) &&\n      is.store(clock)\n    ) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      // @ts-expect-error\n      target = createStore(initialState, {name, sid, or: metadata})\n    } else {\n      target = createEvent({name, derived: true, or: metadata})\n      applyTemplate('sampleTarget', getGraph(target))\n    }\n  }\n  // const targetTemplate =\n  //   isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  const clockState = createStateRef()\n  let filterNodes: Cmd[] = []\n  if (filterType === 'unit') {\n    const [filterRef, hasFilter] = syncSourceState(\n      filter as DataCarrier,\n      target,\n      // @ts-expect-error\n      clock,\n      clockState,\n      method,\n    )\n    filterNodes = [...readAndFilter(hasFilter), ...readAndFilter(filterRef)]\n  }\n  const [sourceRef, hasSource] = syncSourceState(\n    // @ts-expect-error\n    source,\n    target,\n    clock,\n    clockState,\n    method,\n  )\n  const jointNode = createLinkNode(\n    // @ts-expect-error\n    clock,\n    target,\n    [\n      applyTemplate('sampleSourceLoader'),\n      mov({from: STACK, target: clockState}),\n      ...readAndFilter(hasSource),\n      read(sourceRef, true, batched),\n      ...filterNodes,\n      read(clockState),\n      filterType === 'fn' && userFnCall((src, _, {a}) => filter(src, a), true),\n      fn && userFnCall(callStackAReg),\n      applyTemplate('sampleSourceUpward', isUpward),\n    ],\n    method,\n    fn,\n  )\n  // @ts-expect-error\n  own(source, [jointNode])\n  Object.assign(jointNode.meta, metadata, {joint: true})\n  return target\n}\n\nconst readAndFilter = (state: StateRef) => [\n  read(state),\n  calc((upd, scope, {a}) => a, true),\n]\n\nconst syncSourceState = (\n  source: DataCarrier,\n  target: DataCarrier | DataCarrier[],\n  clock: DataCarrier | DataCarrier[],\n  clockState: StateRef,\n  method: string,\n) => {\n  const isSourceStore = is.store(source)\n  const sourceRef = isSourceStore ? getStoreState(source) : createStateRef()\n  const hasSource = createStateRef(isSourceStore)\n  if (!isSourceStore) {\n    createNode({\n      parent: source,\n      node: [\n        mov({from: STACK, target: sourceRef}),\n        mov({from: VALUE, store: true, target: hasSource}),\n      ],\n      family: {owners: [source, target, clock], links: target},\n      meta: {op: method},\n      regional: true,\n    })\n  }\n  applyTemplate('sampleSource', hasSource, sourceRef, clockState)\n  return [sourceRef, hasSource] as const\n}\n","import {processArgsToConfig} from './config'\nimport {validateSampleConfig, createSampling} from './sample'\n\nexport function guard(...args: any[]) {\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  validateSampleConfig(config, 'guard')\n  return createSampling(\n    'guard',\n    config.clock,\n    source,\n    config.filter,\n    config.target,\n    null,\n    config.name,\n    metadata,\n    !config.greedy,\n    false,\n    true,\n  )\n}\n","export const observableSymbol =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import type {Node, StateRef, NodeUnit} from './index.h'\nimport type {Scope, Store, CommonUnit, Domain} from './unit.h'\n\nexport const getGraph = (graph: NodeUnit): Node =>\n  (graph as {graphite: Node}).graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: Store<any>): StateRef => store.stateRef\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: Store<any>) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any): Scope | void => val.scope\nexport const getMeta = (unit: NodeUnit, field: string) =>\n  getGraph(unit).meta[field]\nexport const setMeta = (unit: NodeUnit, field: string, value: unknown) =>\n  (getGraph(unit).meta[field] = value)\nexport const getCompositeName = (unit: CommonUnit | Domain) =>\n  unit.compositeName\n","import type {Kind, Unit} from './index.h'\nimport type {Domain, Effect, Event, Scope, Store} from './unit.h'\nimport {DOMAIN, STORE, EVENT, EFFECT, SCOPE} from './tag'\nimport {isObject, isFunction} from './is'\nimport {getMeta} from './getter'\n\nexport const unit = (obj: unknown): obj is Unit<any> =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: Kind) => (obj: unknown) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE) as (value: unknown) => value is Store<unknown>\nexport const event = is(EVENT) as (value: unknown) => value is Event<unknown>\nexport const effect = is(EFFECT) as (\n  value: unknown,\n) => value is Effect<unknown, unknown, unknown>\nexport const domain = is(DOMAIN) as (value: unknown) => value is Domain\nexport const scope = is(SCOPE) as (value: unknown) => value is Scope\nexport const attached = (unit: unknown) =>\n  effect(unit) && getMeta(unit, 'attached') === true\n","const idCount = () => {\n  let id = 0\n  return () => `${++id}`\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","import type {Template} from '../forest/index.h'\nimport type {NodeUnit} from './index.h'\nimport {getParent, getMeta} from './getter'\nimport {createNode} from './createNode'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value: any\n  template: Template | null\n  sidRoot?: string\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const readTemplate = (): Template | null =>\n  regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}|${sid}`\n  return sid\n}\n\nexport function withRegion(unit: NodeUnit, cb: () => void) {\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template: getMeta(unit, 'template') || readTemplate(),\n    sidRoot: getMeta(unit, 'sidRoot') || (regionStack && regionStack.sidRoot),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const sidNode = createNode({\n    meta: {sidRoot: readSidRoot(sid), name, loc, method},\n  })\n  return withRegion(sidNode, fn)\n}\n","import type {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\nimport {add, forEach} from './collection'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  forEach(links, _link => {\n    const link = getGraph(_link)\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    add(getOwners(link), owner)\n    add(getLinks(owner), link)\n  })\n}\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport type {DataCarrier} from './unit.h'\nimport {getMeta} from './getter'\n\nexport const isObject = (value: unknown): value is Record<any, any> =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function'\n\nexport const isVoid = (value: unknown): value is void => value === undefined\n\nexport const assertObject = (value: unknown) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: unknown,\n  method: string,\n  valueName: string,\n  reason: string,\n): asserts value is DataCarrier =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: unknown,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    //@ts-expect-error some ts assertion edge case\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    deprecate(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\"`,\n      `createEvent/createStore`,\n    ),\n  )\n","import type {Stack} from './index.h'\n\nexport const callStackAReg = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(stack, a)\nexport const callARegStack = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: {[key: string]: any}, _: Stack) =>\n  fn(stack)\n","import type {\n  StateRef,\n  Compute,\n  MovValueToRegister,\n  MovValueToStore,\n  MovStoreToRegister,\n  MovStoreToStore,\n  MovRegisterToStore,\n  Stack,\n} from './index.h'\nimport {nextStepID} from './id'\nimport {EFFECT, REG_A, SAMPLER, STACK, STORE} from './tag'\nimport type {BarrierPriorityTag} from './kernel'\nimport {callStack} from './caller'\n\nconst cmd = <Type extends 'compute' | 'mov'>(\n  type: Type,\n  data: any,\n  priority?: BarrierPriorityTag | false,\n  batch?: boolean,\n) => {\n  const result: {\n    id: string\n    type: Type\n    data: any\n    order?: {\n      priority: BarrierPriorityTag\n      barrierID?: number\n    }\n  } = {\n    id: nextStepID(),\n    type,\n    data,\n  }\n  if (priority) {\n    result.order = {priority}\n    if (batch) result.order.barrierID = ++nextBarrierID\n  }\n  return result\n}\n\nlet nextBarrierID = 0\n\nexport const mov: {\n  <T>(data: {\n    from: 'value'\n    store: T\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToStore<T>\n  <T>(data: {\n    from: 'value'\n    to: 'stack' | 'a' | 'b'\n    store: T\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToRegister<T>\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    to: 'a' | 'b' | 'stack'\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    store: StateRef\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovStoreToStore\n  (data: {\n    store: StateRef\n    to: 'stack' | 'a' | 'b'\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  (data: {\n    store: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  // (data: {\n  //   from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  //   to?: 'stack' | 'a' | 'b' | 'store'\n  //   store?: StateRef\n  //   target?: StateRef\n  // }): Mov\n} = ({\n  from = STORE,\n  store,\n  target,\n  to = target ? STORE : STACK,\n  batch,\n  priority,\n}: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: StateRef\n  target?: StateRef\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n}) => cmd('mov', {from, store, to, target}, priority, batch)\n\nexport const compute = <\n  LocalValues extends {[key: string]: any} = {[key: string]: any},\n>({\n  fn,\n  batch,\n  priority,\n  safe = false,\n  filter = false,\n  pure = false,\n}: {\n  fn?: (data: any, scope: LocalValues, stack: Stack) => any\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n  safe?: boolean\n  filter?: boolean\n  pure?: boolean\n}): Compute => cmd('compute', {fn, safe, filter, pure}, priority, batch)\n\nexport const filter = ({\n  fn,\n  pure,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n  pure?: boolean\n}) => compute({fn, filter: true, pure})\n\nexport const run = ({\n  fn,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => compute({fn, priority: EFFECT})\n\nexport const calc = <\n  LocalValues extends {[key: string]: any} = {[key: string]: any},\n>(\n  fn: (data: any, scope: LocalValues, stack: Stack) => any,\n  filter?: boolean,\n  isEffect?: boolean,\n) => compute({fn, safe: true, filter, priority: isEffect && EFFECT})\n\n/**\n * `read(ref, true, true)`: **reg.stack** with **sampler** batch\n *\n * `read(ref, true, false)`: **reg.stack** without batch\n *\n * `read(ref, false, true)`: **reg.a** with **sampler** batch\n *\n * `read(ref, false, false)`: **reg.a** without batch\n *\n */\nexport const read = (\n  store: StateRef,\n  toStack?: boolean,\n  samplerPriority?: boolean,\n) =>\n  mov({\n    store,\n    to: toStack ? STACK : REG_A,\n    priority: samplerPriority && SAMPLER,\n    batch: true,\n  })\n\nexport const userFnCall = (\n  fn: (data: any, scope: {[key: string]: any}, stack: Stack) => any = callStack,\n  isFilter?: boolean,\n) => compute({fn, pure: true, filter: isFilter})\n\nexport const step = {mov, compute, filter, run}\n","import type {StateRef, StateRefOp} from './index.h'\nimport {nextStepID} from './id'\nimport {add} from './collection'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n\nexport const addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  add(ref.before!, op as any)\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers, getMeta} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-expect-error\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && getMeta(targetNode, 'op') !== 'sample') ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: Map<any, any> | Set<any>) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-expect-error\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import type {Subscription, NodeUnit} from './index.h'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = () => clearNode(node)\n  result.unsubscribe = result\n  return result\n}\n","import {processArgsToConfig} from './config'\nimport {createNode} from './createNode'\nimport type {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet, assertTarget} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit | NodeUnit[],\n  child: NodeUnit | NodeUnit[],\n  node?: Array<Cmd | false | void | null>,\n  op?: string,\n  scopeFn?: Function,\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope: {fn: scopeFn},\n    meta: {op},\n    family: {owners: [parent, child], links: child},\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  const method = 'forward'\n  const [{from, to}, config] = processArgsToConfig(opts, true)\n  assertNodeSet(from, method, '\"from\"')\n  assertNodeSet(to, method, '\"to\"')\n  assertTarget(method, to, 'to')\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta: {op: method, config},\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {run} from './step'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assert} from './throw'\nimport {isFunction} from './is'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  assert(isFunction(handler), '.watch argument should be a function')\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {owners: unit},\n      regional: true,\n    }),\n  )\n}\n","import { createEffect, createEvent, createStore, guard, is, sample } from 'effector';\nexport function throttle(_ref) {\n  var {\n    source,\n    timeout,\n    target = createEvent({\n      name: \"target\",\n      sid: \"r328r6\"\n    }, {\n      name: \"target\",\n      sid: \"r328r6\"\n    })\n  } = _ref;\n  if (!is.unit(source)) throw new TypeError('source must be unit from effector');\n  var $timeout = toStoreNumber(timeout);\n  var timerFx = createEffect(timeout => new Promise(resolve => setTimeout(resolve, timeout)), {\n    name: \"timerFx\",\n    sid: \"-pyjx8k\"\n  });\n  var start = guard({\n    and: [{\n      clock: source,\n      filter: timerFx.pending.map(pending => !pending)\n    }],\n    or: {\n      name: \"start\",\n      sid: \"-p67kgr\"\n    }\n  });\n  sample({\n    and: [{\n      source: $timeout,\n      clock: start,\n      target: timerFx\n    }],\n    or: {\n      sid: \"-ievrvf\"\n    }\n  });\n  sample({\n    and: [{\n      source,\n      clock: timerFx.done,\n      target\n    }],\n    or: {\n      sid: \"-i01buo\"\n    }\n  });\n  return target;\n}\n\nfunction toStoreNumber(value) {\n  if (is.store(value, {\n    sid: \"-hl6vqh\"\n  })) return value;\n\n  if (typeof value === 'number') {\n    if (value < 0 || !Number.isFinite(value)) throw new Error(\"timeout must be positive number or zero. Received: \\\"\".concat(value, \"\\\"\"));\n    return createStore(value, {\n      and: {\n        name: '$timeout'\n      },\n      sid: \"pu8pon\"\n    });\n  }\n\n  throw new TypeError(\"timeout parameter should be number or Store. \\\"\".concat(typeof value, \"\\\" was passed\"));\n}"],"names":["hasOwn","hasOwnProperty","classNames","classes","i","arguments","length","arg","argType","push","Array","isArray","inner","apply","toString","Object","prototype","includes","key","call","join","module","exports","default","e","require","k","is","a","b","l","useState","m","useEffect","n","useLayoutEffect","p","useDebugValue","r","getSnapshot","value","d","f","u","window","document","createElement","inst","c","g","useSyncExternalStore","h","q","t","useRef","v","useMemo","w","useSyncExternalStoreWithSelector","current","hasValue","_arrayLikeToArray","arr","len","arr2","asyncGeneratorStep","gen","resolve","reject","_next","_throw","info","error","done","Promise","then","_asyncToGenerator","fn","self","this","args","err","undefined","_defineProperty","obj","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread2","target","source","forEach","getOwnPropertyDescriptors","defineProperties","_typeof","Symbol","iterator","constructor","_regeneratorRuntime","Op","desc","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","create","context","Context","makeInvokeMethod","tryCatch","type","ContinueSentinel","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","method","_invoke","AsyncIterator","PromiseImpl","invoke","record","result","__await","unwrapped","previousPromise","callInvokeWithMethodAndArg","state","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","TypeError","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","iter","val","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","_slicedToArray","_i","_s","_e","_arr","_n","_d","unsupportedIterableToArray","_toConsumableArray","arrayLikeToArray","from","_unsupportedIterableToArray","o","minLen","test","createWatch","store","scope","batchStep","seq","step","unshift","node","createNode","id","graphite","scopeLinks","additionalLinks","links","idx","indexOf","splice","clearNode","parent","family","owners","withDisplayName","Component","useStoreBase","throwError","subscribe","React","cb","read","stateReader","useStoreMapBase","defaultValue","configOrStore","separateFn","updateFilter","basicUpdateFilter","stateRef","valueRef","keysRef","isEqual","update","getScope","forceScope","ScopeContext","useStore","opts","useList","list","renderItem","getKey","placeholder","Item","shortName","props","index","keyVal","fnRef","item","keysSelfMemo","listItems","map","_","message","getState","upd","oldValue","Provider","forIn","assert","condition","to","child","meta","familyRaw","regional","sources","arrifyNodes","add","nextNodeID","link","getOwners","owner","getLinks","regionStack","own","getValue","launch","unit","payload","upsert","pageForLaunch","currentPage","stackForLaunch","forkPageForLaunch","forkPage","params","defer","page","stack","getForkPage","pushFirstHeapItem","getGraph","isRoot","skip","reg","lastStartedState","isWatch","isPure","kernelLoop","hasPageReg","hasScopeReg","local","fail","stepn","order","priority","barrierID","fullID","barriers","has","pushHeap","delete","data","STACK","pageForRef","getPageForRef","initRefInScope","softRead","readRef","getPageRef","getMeta","pure","computationResult","safe","tryRun","finalValue","nextNode","fxCount","storeChange","warnSerializeNode","deleteMin","unitObjectName","objOrArr","comma","getCompositeName","fullName","createName","path","composite","concat","processArgsToConfig","singleArgument","rawConfig","assertObject","metadata","or","childConfig","and","unwrappedNestedValue","isObject","nested","applyTemplate","template","readTemplate","handlers","createEvent","nameOrConfig","maybeConfig","config","flattenConfig","event","deprecate","oldPage","getParent","setCurrentPage","finalEvent","assign","initUnit","watch","watchUnit","deriveEvent","MAP","userFnCall","callStack","filterMap","calc","isVoid","prepend","contramapped","createLinkNode","applyParentHook","domain","hooks","createStore","defaultState","plainState","createStateRef","updates","named","derived","plainStateId","subscribers","Map","reachedPage","targetRef","setState","units","on","nodeSet","assertNodeSet","isFunction","trigger","off","getSubscribers","set","createSubscription","updateStore","callARegStack","currentSubscription","get","firstState","lastResult","storeState","innerStore","linkNode","callStackAReg","addRefOp","getStoreState","noInit","eventOrFn","subscription","defaultConfig","mov","serializeMeta","ignored","customSerialize","sid","setMeta","serialize","reinit","combine","handler","stores","structStoreShape","shapeReady","noArraySpread","rawHandler","storeCombination","createDefer","req","rs","rj","catch","createEffect","instance","kind","use","runner","getCurrent","anyway","finally","status","doneData","failData","handlerId","getType","scope_","handler_","scopeRef","createScopeRef","onResolve","onSettled","onReject","runFn","ok","op","fx","savedFork","setForkPage","inFlight","x","pending","amount","effect","merge","validateSampleConfig","atLeastOneFieldExists","sampleConfigFields","field","fieldErrorMessage","sample","clock","batched","greedy","createSampling","guard","observableSymbol","observable","graph","compositeName","attached","removeItem","pos","subject","suggestion","console","idCount","nextUnitID","nextStepID","readSidRoot","sidRoot","ownerUnit","_link","flat","assertNodeSetItem","valueName","reason","assertTarget","targetField","cmd","batch","nextBarrierID","compute","run","isEffect","toStack","samplerPriority","isFilter","ref","before","heap","getPriority","ret","queue","ix","first","last","size","bucket","Set","newForkPage","newPage","isGetState","noopParser","sourceRef","isKernelCall","refsMap","_sourceRef$meta","sidValuesMap","sidIdMap","fromSerialize","isFresh","needToAssign","part","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","clearMap","clear","ownerSet","history","events","effects","domains","unsubscribe","scopeFn","hookType","isDomain","unitId","thru","observer","nativeTemplate","mapped","caller","storeRef","reader","needSpread","clone","stateNew","rawShape","storeStateRef","rawShapeReader","childRef","defaultShape","activeEffects","sidechain","targetMayBeStore","filterRequired","isUpward","sourceIsClock","filterType","clockState","filterNodes","syncSourceState","filterRef","hasFilter","readAndFilter","hasSource","jointNode","src","joint","isSourceStore","throttle","_ref","timeout","$timeout","Number","isFinite","toStoreNumber","timerFx","setTimeout","start"],"sourceRoot":""}